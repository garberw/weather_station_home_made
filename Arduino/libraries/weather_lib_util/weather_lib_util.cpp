/*
  the script WEATHER-AUTO-SER-PRINT.sh
  automatically generates config file for ser_print() "weather_lib_util_ser_print.h";
  the config file defines global display_table;
  
  the gcc compiler provides variables (not macros) __FILE__ and __func__
  the combination identifies an exact unique function;
  
  NOTE:
  there are very few exceptions which have to be handled separately;
  there was only one non unique "duplicate" so far;
  
  ... ser_print_hash_function(__FILE__, __func__);
  
  attempt to generate an index into the hash table which has few collisions
  (a collision is when different combinations hash to the same index);

  ... hash table
  
  at a given index in hash table store
  bool; whether printing is on (1) or off (0) for that combination; and;
  pointer; F(__FILE_); and;
  pointer; F(__func__); 

  ... ser_print_store(bool used, __FILE__, __func__);
  
  use ser_print_hash_function(__FILE__, __func__) to compute the hash index;
  this combination is the same as in weather_lib_util_ser_print.h;
  store above values at that index in hash table;

  ... ser_print_load(__FILE__,__func__)
  
  use ser_print_hash_function(__FILE__, __func__) to compute the hash index;
  this combination is the same as in weather_lib_util_ser_print.h;
  load (get/return) result "used" = whether printing on/off from that index in hash table;

  ... macro FUNC_BEGIN (no args)
  
  use FUNC_BEGIN at the beginning of each function using ser_print();
  declares a variable LOCK which is an instance of the serial_print_lock class;
  LOCK constructor calls ser_print_load()
  which returns used == (value in hash table that tells if printing on/off);
  pushes used on stack for global access using static_serial_print.used();
  used is then accessible to ser_print;
  LOCK destructor pops used off stack;
  destructor is called by c++ automatically at function return;
  no FUNC_END is needed (so far !!!!);

  ... ser_print()
  
  if (static_serial_print.used()) Serial.print();
  where Serial.print() is normal Arduino print function;
*/

#include <weather_lib_util.h>
// not a real header;
// it is automatically generated by the script WEATHER-AUTO-SER-PRINT.sh;
// it is not typdefs or function prototypes (declarations);
// it is data (definitions);
// this code is for inclusion in this file only;
#include <weather_lib_util_ser_print.h>

/* globals begin ----------------------------------------------- */

char snprintf_buf[SNPRINTF_BUF_MAX];

bool halt_state = false;

weather_exception wexception;

int memory_free_min = freeMemory();

serial_print static_serial_print;

const char main_name[] = "main";

/* globals end ----------------------------------------------- */
/* error checking begin ----------------------------------------------- */

// weather_exception public interface begin ------------------------------

// nearly every function calls serial_print:: functions and exceptions;
// exceptions do not rely on anything else;
// they always print with arduino Serial.print() not ser_print();
// if serial_print is self contained except for calling
// (1) itself
// (2) exceptions
// calling a member function should never indirectly refer back to
// serial print in a recursive infinite loop;


void divider_line_error_lead1(void) {
  for (int i = 0; i < 6; i++) {
    Serial.print(F("-"));
  }
  Serial.print(F(" "));
}

// not inline; takes up too much space;
// assume this is called by ERROR_* macro with goto catch_block;
void weather_error_condition(const char *function_name, format_string msg) {
  // push error
  wexception.push(function_name, msg);
  // warning
  divider_line_error_lead1();
  Serial.print(F("error_return  ; "));
  Serial.print(function_name);
  Serial.print(F("; "));
  Serial.println(msg);
  Serial.flush();
  // backtrace
  static_serial_print.backtrace();
  Serial.flush();
  // goto catch_block
}

// not inline; takes up too much space;
// assume this is called by ERROR_* macro with goto catch_block;
void weather_error_fatal(const char *function_name, format_string msg) {
  // push error
  wexception.push(function_name, msg);
  // warning
  divider_line_error_lead1();
  Serial.print(F("error_fatal   ; "));
  Serial.print(function_name);
  Serial.print(F("; "));
  Serial.println(msg);
  Serial.flush();
  // backtrace
  static_serial_print.backtrace();
  Serial.flush();
  // fixme halt
}

// not inline; takes up too much space;
// assume this is called by ERROR_* macro with goto catch_block;
void weather_error_return(const char *function_name, format_string msg) {
  // do not push error
  // warning
  divider_line_error_lead1();
  Serial.print(F("error_return  ; "));
  Serial.print(function_name);
  Serial.print(F("; "));
  Serial.println(msg);
  Serial.flush();
  // goto catch_block
}

// not inline; takes up too much space;
// assume this is called by ERROR_* macro with goto catch_block;
void weather_error_catch(const char *function_name) {
  // if any previously pushed errors exist
  // warning
  divider_line_error_lead1();
  Serial.print(F("error_catch   ; "));
  Serial.print(function_name);
  Serial.println(F("; "));
  Serial.flush();
  // goto catch block
}

// weather_exception public interface end ------------------------------
// weather_exception members begin ------------------------------

void weather_exception::push(const char *function_name, format_string msg) {
  if (m_nerror >= EXCEPTION_STACK_MAX) {
    divider_line_error_lead1();
    Serial.println(F("error:  exception stack overflow"));
    return;
  }
  if (m_nerror < 0) {
    divider_line_error_lead1();
    Serial.println(F("error:  exception stack underflow"));
    return;
  }
  m_function_name[m_nerror] = function_name;
  m_msg[m_nerror] = msg;
  m_nerror++;
}

// requires Serial.begin() called;
void weather_exception::print(void) {
  divider_line_error_lead1();
  Serial.println(F("exception::print;"));
  divider_line_error_lead1();
  Serial.print(F("m_nerror = ")); Serial.println(m_nerror);
  for (byte j = 0; j < m_nerror; j++) {
    divider_line_error_lead1();
    Serial.print(F("j=")); Serial.print(j); Serial.print(F("; "));
    Serial.print(m_function_name[j]); Serial.print(F("; "));
    Serial.println(m_msg[j]);
  }
  Serial.flush();
}

// weather_exception members end ------------------------------
// ser_print public interface begin ------------------------------
/*
  at global scope before any functions run
  static_serial_print calls the default constructor for serial_print::
  which sets m_setup_done=false and bottom of stack m_used_now[0] = true;
  
  FUNC_BEGIN does not work until m_setup_done=true;
  before that it returns default m_used_now = true;
  the one and only effect of this is that ser_print()
  always prints before m_setup_done=true;
  
  therefore FUNC_BEGIN ser_print and exceptions
  (1) can be used in same locations before and after m_setup_done;
  (2) can be used in all of the members called by ser_print::setup() without circular references;
  but ser_print() will always print before m_setup_done;
*/

// ser_print public interface includes only
// ser_print and ser_println templates in header
// plus ...;

void ser_setup(void) {
  static_serial_print.setup();
}

void ser_println(void) {
  if (static_serial_print.used_now()) Serial.println();
}


// ser_print public interface end ------------------------------
// serial_print members begin ------------------------------
/*
  ERROR_* macros in serial_print may call static_serial_print.backtrace();
  during setup ...
  this will not crash because constructor sets m_stack_top = 0;
  they just will not print anything for backtrace;
*/

// the only things calling push and pop should be LOCK constructor and destructor;

// m_stack_top is number of elements on stack;
// next push goes in m_used_now[m_stack_top++];
// next pop  is from m_used_now[--m_stack_top];
// m_stack_top = 0 ... SERIAL_PRINT_STACK_MAX
// m_stack_top == 0                      if empty;
// m_stack_top == SERIAL_PRINT_STACK_MAX if full; (MAX = number of elements in array);
// you can start empty;
// you can pop everything off the stack;
// you can not pop  when empty;
// you can not push when full;
bool serial_print::check_stack(int new_top) {
  if (new_top < 0) {
    Serial.println("error; stack underflow;");
    return false;
  }
  if (new_top > SERIAL_PRINT_STACK_MAX) {
    Serial.println("error; stack overflow;");
    return false;
  }
  return true;
}

bool serial_print::used_now(void) {
  // return true as default on error
  // fixme optimize by removing this check if it never gives a bug;
  // this check is not necessary if stack is only manipulated by push and pop
  if (!check_stack(m_stack_top)) return true;
  return m_used_now[m_stack_top-1];
}

void serial_print::push_used_now(bool used, const char *func) {
  int next_top = m_stack_top + 1;
  if (!check_stack(next_top)) return;
  m_used_now[m_stack_top] = used;
  m_func_now[m_stack_top] = func;
  m_stack_top = next_top;
}

void serial_print::pop_used_now(void) {
  int next_top = m_stack_top - 1;
  if (!check_stack(next_top)) return;
  m_stack_top = next_top;
}

// SERIAL_PRINT_HASH_MAX == approx 2300
// len                   == approx 340
// store does not encounter many hash collisions
void serial_print::setup(void) {
  // use the header automatically generated by the bash script;
  Serial.println(F("sizeof(display_table); sizeof(serial_print_entry)"));
  Serial.flush();
  int sz1 = sizeof(display_table);
  int sz2 = sizeof(serial_print_entry);
  int len;
  Serial.println(F("setting data to NULL or false"));
  Serial.flush();
  // m_used_now = true;
  for (int idx = 0; idx < SERIAL_PRINT_HASH_MAX; idx++) {
    m_hash_file[idx] = NULL;
    m_hash_func[idx] = NULL;
    m_hash_used[idx] = false;
  }
  m_store_pass = 0;
  m_store_fail = 0;
  m_store_dupl = 0;
  m_store_coll = 0;
  ERROR_CONDITION((sz1 % sz2 == 0), F("impossible display_table"));
  len = sz1 / sz2;
  for (int e = 0; e < len; e++) {
    // fixme
    // Serial.println(F("serial_print::setup display_table[e];")); Serial.flush();
    // Serial.print(F("e    = ")); Serial.println(e); Serial.flush();
    serial_print_entry &entry = display_table[e];
    // fixme
    // Serial.print(F("used = ")); Serial.println(entry.m_used); Serial.flush();
    // Serial.print(F("file = ")); Serial.println(entry.m_file); Serial.flush();
    // Serial.print(F("func = ")); Serial.println(entry.m_func); Serial.flush();
    store(entry.m_used, entry.m_file, entry.m_func, e);
    // Serial.flush();
  }
  watchdog_reset();
  Serial.print(F("m_store_pass = ")); Serial.println(m_store_pass);
  Serial.print(F("m_store_fail = ")); Serial.println(m_store_fail);
  Serial.print(F("m_store_dupl = ")); Serial.println(m_store_dupl);
  Serial.print(F("m_store_coll = ")); Serial.println(m_store_coll);
  ERROR_CONDITION((m_store_pass == len), F("display_table; all did not pass;"));
  Serial.println(F("serial_print::m_setup_done = true"));
  m_setup_done = true;
  return;
 catch_block:
  wexception.print();
  // fixme
  // weather_halt();
  // fixme
  Serial.flush();
}

// src = fff
// dest = buf
void serial_print::copy_flash_to_char(format_string fff, char *buf) {
  String FFF(fff);
  int len = FFF.length();
  ERROR_CONDITION(((len + 1) <= SERIAL_PRINT_BUF_MAX), F("hash_function buffer overflow"));
  // amazingly String does not have a function to copy to a char *;
  for (int c = 0; c < len; c++) {
    buf[c] = FFF[c];
  }
  buf[len] = 0;
  return;
 catch_block:
  wexception.print();
  // fixme
  //  weather_halt();
  // fixme
  Serial.flush();
}

// src = fff
// dest = buf
void serial_print::copy_char_to_char(const char *fff, char *buf) {
  int len = strlen(fff);
  ERROR_CONDITION(((len + 1) <= SERIAL_PRINT_BUF_MAX), F("hash_function buffer overflow"));
  // strcpy(dest, src);
  strcpy(buf, fff);
  return;
 catch_block:
  wexception.print();
  // fixme
  //  weather_halt();
  // fixme
  Serial.flush();
}

// m_file1 and m_func1 may be overwritten; check if still valid before use;
void serial_print::save_names1(format_string file, format_string func) {
  copy_flash_to_char(file, m_file1);
  copy_flash_to_char(func, m_func1);
}

// m_file2 and m_func2 may be overwritten; check if still valid before use;
void serial_print::save_names2(format_string file, format_string func) {
  copy_flash_to_char(file, m_file2);
  copy_flash_to_char(func, m_func2);
}

// m_file1 and m_func1 may be overwritten; check if still valid before use;
void serial_print::save_names1(const char *file, const char *func) {
  copy_char_to_char(file, m_file1);
  copy_char_to_char(func, m_func1);
}

// m_file2 and m_func2 may be overwritten; check if still valid before use;
void serial_print::save_names2(const char *file, const char *func) {
  copy_char_to_char(file, m_file2);
  copy_char_to_char(func, m_func2);
}

uint16_t serial_print::hash_function(const char *file, const char *func) {
  uint32_t idx = 0;
  int j = 0;
  uint8_t c;
  while (c = file[j++]) {
    idx = SERIAL_PRINT_HASH_BASE * idx + c;
    idx %= SERIAL_PRINT_HASH_MAX;
  }
  int k = 0;
  while (c = func[k++]) {
    idx = SERIAL_PRINT_HASH_BASE * idx + c;
    idx %= SERIAL_PRINT_HASH_MAX;
  }
  return idx;
}

// TTT == format_string  OR
// TTT == const char *
template <typename TTT>
void serial_print::diagnostic(format_string where,
                              format_string result,
                              int attempt,
                              int jjj,
                              int used,
                              TTT file,
                              TTT func,
                              bool empty,
                              int tag)
{
  // this whole function is for debugging but it is only used in setup;
  bool debug = false;
  format_string space = F(" ");
  if (tag >= 0) {
    // tag = index e of entry in display_table;
    Serial.print(tag); Serial.print(space);
  }
  // load or store
  Serial.print(where); Serial.print(space);
  // pass or fail
  Serial.print(result); Serial.print(space);
  // number of collisions
  Serial.print(attempt); Serial.print(space);
  // current index
  Serial.print(jjj); Serial.print(space);
  // used to load or store
  Serial.print(used); Serial.print(space);
  // file to load or store
  Serial.print(file); Serial.print(space);
  // func to load or store
  Serial.print(func); Serial.print(space);
  if (debug) {
    // file to load or store char * version
    Serial.print(m_file1); Serial.print(space);
    // func to load or store char * version
    Serial.print(m_func1); Serial.print(space);
    // if (empty) load or store returns before save_names2 defines m_file2 and m_func2;
    if (!empty) {
      // file to load or store char * version
      Serial.print(m_file2); Serial.print(space);
      // func to load or store char * version
      Serial.print(m_func2); Serial.print(space);
    }
  }
  Serial.println();
  // fixme
  Serial.flush();
}

void serial_print::store(bool used, format_string file, format_string func, int tag) {
  format_string where = F("store");
  save_names1(file, func);
  uint16_t idx = hash_function(m_file1, m_func1);
  uint16_t jjj = idx;
  int attempt = 0;
  do {
    bool empty1 = (m_hash_file[jjj] == NULL);
    bool empty2 = (m_hash_func[jjj] == NULL);
    bool empty = (empty1 || empty2);
    if (empty1 != empty2) {
      m_store_fail++;
      diagnostic(where, F("fail     "), attempt, jjj, used, file, func, empty, tag);
      ERROR_CONDITION((empty1 == empty2), F("empty1 != empty2"));
    }
    if (empty) {
      m_store_pass++;
      m_hash_file[jjj] = file;
      m_hash_func[jjj] = func;
      m_hash_used[jjj] = used;
      diagnostic(where, F("pass     "), attempt, jjj, used, file, func, empty, tag);
      return;
    }
    save_names2(m_hash_file[jjj], m_hash_func[jjj]);
    bool found1 = !strcmp(m_file1, m_file2);
    bool found2 = !strcmp(m_func1, m_func2);
    bool found = (found1 && found2);
    if (found) {
      m_store_dupl++;
      diagnostic(where, F("duplicate"), attempt, jjj, used, file, func, empty, tag);
      ERROR_CONDITION((!found), F("duplicate store"));
    }
    // collision; two unique combinations (file+func) hash to the same thing;
    m_store_coll++;
    diagnostic(where, F("collision"), attempt, jjj, used, file, func, empty, tag);
    jjj = (jjj + 1) % SERIAL_PRINT_HASH_MAX;
    attempt++;
  } while (jjj != idx);
  m_store_fail++;
  ERROR_CONDITION((false), F("hash table full"));
  // fixme
  Serial.flush();
  return;
 catch_block:
  wexception.print();
  // fixme
  // weather_halt();
  // fixme
  Serial.flush();
}

bool serial_print::load(const char *file_raw, const char *func) {
  // !!!!!!!! do not use FUNC_BEGIN !!!!!!!!;
  // that macro calls this function load() and would recur indefinitely;
  bool debug = false;
  format_string where = F("load");
  uint16_t idx;
  uint16_t jjj;
  int attempt;
  
  // this is a form of documentation; default of whether display switched on for this file/func;
  bool used_default = true;

  if (!m_setup_done) {
    return used_default;
  }

  // file = basename(file_raw);
  char c;
  const char *file = file_raw;
  while (c = *file_raw++) {
    if (c == '/') {
      file = file_raw;
    }
  }
  ERROR_CONDITION((*file != '\0'), F("file empty"));
  
  // fixme chicken out;
  // m_used_now = used_default;
  // return used_default;
  
  save_names1(file, func);
  idx = hash_function(file, func);
  jjj = idx;
  attempt = 0;
  do {
    bool empty1 = (m_hash_file[jjj] == NULL);
    bool empty2 = (m_hash_func[jjj] == NULL);
    bool empty = (empty1 || empty2);
    if (empty1 != empty2) {
      if (debug) diagnostic(where, F("fail     "), attempt, jjj, -1, file, func, true);
      ERROR_CONDITION((empty1 == empty2), F("empty1 != empty2"));
    }
    if (empty) {
      if (debug) diagnostic(where, F("fail     "), attempt, jjj, -1, file, func, true);
      ERROR_CONDITION((!empty), F("none found at first attempt"));
    }
    save_names2(m_hash_file[jjj], m_hash_func[jjj]);
    bool found1 = !strcmp(m_file1, m_file2);
    bool found2 = !strcmp(m_func1, m_func2);
    bool found = (found1 && found2);
    if (found) {
      bool used = m_hash_used[jjj];
      // bool used = m_used_now = m_hash_used[jjj];
      if (debug) diagnostic(where, F("pass     "), attempt, jjj, used, file, func, true);
      return used;
    }
    // collision; two unique combinations (file+func) hash to the same thing;
    if (debug) diagnostic(where, F("collision"), attempt, jjj, -1, file, func, empty);
    jjj = (jjj + 1) % SERIAL_PRINT_HASH_MAX;
    attempt++;
  } while (jjj != idx);
  ERROR_CONDITION((false), F("never found"));
 catch_block:
  wexception.print();
  // fixme
  // weather_halt();
  // fixme
  Serial.flush();
  return used_default;
}

void serial_print::backtrace(void) {
  for (int frame = 0; frame < m_stack_top; frame++) {
    Serial.print("frame = ");
    Serial.print(frame);
    Serial.print(" func = ");
    Serial.println(m_func_now[frame]);
  }
}

// serial_print members end ------------------------------

int setup_communication_ser0(void) {
  // Serial.begin(115200);
  // start the built-in serial port, for Serial Monitor
  Serial.begin(SERIAL_PRINT_BAUD);
  // if you are using a board with 'native USB'
  // make sure the while (!Serial) line is commented out
  // if you are not tethering to a computer,
  // as it will cause the microcontroller to halt until a USB connection is made!
  pause_on_start();
  Serial.println(F("Serial working;"));
  Serial.flush();
  delay(1000);
  return 0;
}

// applies to static part used by all weather_sensor
// wind and temp are both;
// DATA = 8 bit binary;
// PARITY = NO;
// STOP BIT = 1;
// default temp is 9600 baud
// default wind is 4800 baud
int setup_communication_ser1(void) {
  // pinMode(pin_RTS, OUTPUT);
  // should stay in receive mode whenever not writing
  // digitalWrite(pin_RTS, RS485Receive);
  // start the Modbus serial port
  RS485Serial.begin(RS485Serial_BAUD);
  // not needed for SoftwareSerial;
  // while (!RS485Serial); 
  Serial.println(F("RS485Serial working;"));
  Serial.flush();
  delay(1000);
  return 0;
}

void pause_on_start(void) {
  if (PAUSE_ON_START) {
    while (!Serial) {
      delay(100);
    }
  }
}

void setup_delay(void) {
  delay(SETUP_DELAY);
}

// requires Serial.begin() called;
void weather_halt(void) {
  Serial.println(F("halted; flushing output"));
  Serial.flush();
  while (1) {
    Serial.print(F("halted time = ")); Serial.println(millis());
    wexception.print();
    Serial.flush();
    delay(2000);
  }
}

void check_halt(void) {
  if (!halt_state) return;
  weather_halt();
}

// print functions begin ---------------------------------------------

// NONE OF THE PRINT FUNCTIONS USE FUNC_BEGIN
// they get it from enclosing function

void divider_line(format_string str, int n) {
  for (int i = 0; i < n; i++) {
    ser_print(str);
  }
}

void divider_line_error_lead(void) {
  divider_line(F("-"), 6);
  Serial.print(F(" "));
}

void divider_line_result(result_type result, format_string name) {
  divider_line_error_lead();
  ser_print(name);
  if (result == RESULT_SUCCESS) {
    ser_print(F(" success "));
    divider_line(F("-"), 60);
  } else {
    ser_print(F(" FAIL "));
    divider_line(F("\\"), 20); 
  }
  ser_println();
}

void divider_line_loop_begin(void) {
  divider_line(F("="), 60); ser_println(F(" LOOP BEGIN"));
}

void divider_line_sensor(format_string name) {
  divider_line(F("="), 8);
  ser_print(F(" "));
  ser_print(name);
  ser_print(F(" "));
  divider_line(F("="), 8);
  ser_println();
}

// print nine digits padded with leading spaces
void print_uint32(uint32_t n) {
  static const uint32_t f = 1000000000;
  uint32_t b = f;
  int d = 9;
  while (d > 0) {
    uint32_t c = n / b;
    if (c) break;
    ser_print(F(" "));
    n %= b;
    b /= 10;
    d--;
  }
  while (d >= 0) {
    uint32_t c = n / b;
    ser_print(c);
    n %= b;
    b /= 10;
    d--;
  }
}

// pad with leading zeroes
void print_hex_8(byte d) {
  ser_print(d / 16, HEX); ser_print(d % 16, HEX);
  //  if (d < 16) ser_print(F("0"));
  //  ser_print(d, HEX);
}

// pad with leading zeroes
void print_hex_16(uint16_t w) {
  print_hex_8(highByte(w));
  print_hex_8(lowByte(w));
}

// pad with leading zeroes
// two digits; up to 99
void print_dec_8(byte d) {
  if (d < 10) ser_print(F("0"));
  ser_print(d);
}

// print functions end ---------------------------------------------

/*
// require call Serial.begin() first
#include <avr/wdt.h>
void watchdog_setup(void) {
  wdt_disable();
  // very dangerous if you delay less than 2000 msec here !!!!;
  // can damage arduino and require reload of bootloader;
  delay(3000);
  // set timeout to 8 seconds (the max);
  wdt_enable(WDTO_8S);
  Serial.println(WDT Enabled);
  // if you do not call wdt_reset() before timeout the arduino will reboot;
}

void watchdog_reset(void) {
  wdt_reset();
}
*/

// require call Serial.begin() first
void watchdog_setup(void) {
  // 8000 msec is the max for my microcontroller;
  // try 32000 and Adafruit library should show the true maximum allowed;
  // (it will bump it down to maximum allowed and return it in countdownMS);
  int countdownMS = Watchdog.enable(8000);
  // int countdownMS = Watchdog.enable(32000);
  Serial.print("Enabled the watchdog with max countdown of ");
  Serial.print(countdownMS, DEC);
  Serial.println(" milliseconds!");
  Serial.println();
  // can also use Watchdog.disable();
  // see Adafruit source code;
}

void watchdog_reset(void) {
  Watchdog.reset();
}

void pack_long_into_uint16_t(uint16_t &H, uint16_t &L, uint32_t D) {
  H = D >> 16;
  L = D & 0xffff;
}

void memcpy_pack_float_into_uint16_t(uint16_t &WH, uint16_t &WL, float FL) {
  // if (sizeof(float) != 4) {
  //   ser_println(F("error:  float not 32 bit"));
  //   weather_halt();
  // }
  uint32_t UI;
  memcpy(&UI, &FL, sizeof(uint32_t));
  WH = UI >> 16;
  WL = UI & 0xffff;
}

void memcpy_unpack_uint16_t_into_float(uint16_t WH, uint16_t WL, float &FL) {
  // if (sizeof(float) != 4) {
  //   ser_println(F("error:  float not 32 bit"));
  //   weather_halt();
  // }
  uint32_t WH2 = WH;
  uint32_t WL2 = WL;
  uint32_t UI = (WH2 << 16) | WL2;
  memcpy(&FL, &UI, sizeof(uint32_t));
}

/* error checking end ----------------------------------------------- */

// eee eof
